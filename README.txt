README

Implemented my version of the Toy-DES in c++. I used mainly vectors of ints to represent in binary the data that was being encrypted. 'B' for example would be converted to the vector [0,1,0,0,0,0,1,0]. First, I converting the file into characters, then to vectors of the bits of the different characters. I found this to be an easier way to think about the different permutations, and the dealing with the S-boxes. 

 I then wrote a function for each of the different Permutations that takes place during DES encryption. These are simple functions that just rearrange a vector of bits. Most of my functions, including these functions, operated on the original object, via pass by reference.
  Left_shift is a function that does a left shift of all the bits in the vector, wrapping any that go over around. I manually entered the S-boxes in the main code and then passed them to the encrypt function. The encrypt function also doubles as the decrypt function depending on the last argument. The only difference is that it switches the keys. All of the functions in DES_reciever are the exact same as in DES, the only difference is that the main has been altered to receive messages instead of sending them. My program does currently have limitations. Instead of continuously looking to see if it's done reading in the file(during the socket part of my program), I just set it to only be able handle files up to 32 kb, which I assumed would be enough for this toy DES. In order to make it handle any size I'd have to loop over it, waiting until it stopped reading. The Key is a 10 digit binary number, so it can be any number between 0 and 1023. It's important for both the sender and the receiver to use the same key, otherwise they won't successfully be able to decipher the message.

I wrote several functions to convert standard data types (strings and chars) to my vectors and matrix data types that I used to encrypt the data. This was necessary since otherwise it would make the data pretty useless.

To run my code, start by compiling both as C++ files. Then run the Receiver program first. Use the command line arguments of [ key, port number] for the receiver, and  [inputfile, key, port, IP address] for the sender. Both sender and receiver will output the encrypted message, as well as decode the message.

I tested my code using the declaration of independence, and sending it from one cygwin terminal to another. I also tried testing with a friend, but somewhere in our implementations, we must have had subtle differences, since even using the same key, we couldn't decipher the sent messages. While Testing I also ran into the issue of certain built in functions not working due to the nature of the cypher text. One example was converting a C-String to a C++ String. Some of the original characters would get converted to the null character. This made it so it would stop reading my message part way through. I remedied this by writing a simple function to solve the problem.
